.\" Automatically generated by Pandoc 3.1.3
.\"
.\" Define V font for inline verbatim, using C font in formats
.\" that render this, and otherwise B font.
.ie "\f[CB]x\f[]"x" \{\
. ftr V B
. ftr VI BI
. ftr VB B
. ftr VBI BI
.\}
.el \{\
. ftr V CR
. ftr VI CI
. ftr VB CB
. ftr VBI CBI
.\}
.TH "RTC_GEOMETRY_TYPE_USER" "3" "" "" "Embree Ray Tracing Kernels 4"
.hy
.SS NAME
.IP
.nf
\f[C]
RTC_GEOMETRY_TYPE_USER - user geometry type
\f[R]
.fi
.SS SYNOPSIS
.IP
.nf
\f[C]
#include <embree4/rtcore.h>

RTCGeometry geometry =
  rtcNewGeometry(device, RTC_GEOMETRY_TYPE_USER);
\f[R]
.fi
.SS DESCRIPTION
.PP
User-defined geometries contain a number of user-defined primitives,
just like triangle meshes contain multiple triangles.
The shape of the user-defined primitives is specified through registered
callback functions, which enable extending Embree with arbitrary types
of primitives.
.PP
User-defined geometries are created by passing
\f[V]RTC_GEOMETRY_TYPE_USER\f[R] to the \f[V]rtcNewGeometry\f[R]
function call.
One has to set the number of primitives (see
\f[V]rtcSetGeometryUserPrimitiveCount\f[R]), a user data pointer (see
\f[V]rtcSetGeometryUserData\f[R]), a bounding function closure (see
\f[V]rtcSetGeometryBoundsFunction\f[R]), as well as user-defined
intersect (see \f[V]rtcSetGeometryIntersectFunction\f[R]) and occluded
(see \f[V]rtcSetGeometryOccludedFunction\f[R]) callback functions.
The bounding function is used to query the bounds of all time steps of a
user primitive, while the intersect and occluded callback functions are
called to intersect the primitive with a ray.
The user data pointer is passed to each callback invocation and can be
used to point to the application\[cq]s representation of the user
geometry.
.PP
The creation of a user geometry typically looks the following:
.IP
.nf
\f[C]
RTCGeometry geometry = rtcNewGeometry(device, RTC_GEOMETRY_TYPE_USER);
rtcSetGeometryUserPrimitiveCount(geometry, numPrimitives);
rtcSetGeometryUserData(geometry, userGeometryRepresentation);
rtcSetGeometryBoundsFunction(geometry, boundsFunction);
rtcSetGeometryIntersectFunction(geometry, intersectFunction);
rtcSetGeometryOccludedFunction(geometry, occludedFunction);
\f[R]
.fi
.PP
Please have a look at the \f[V]rtcSetGeometryBoundsFunction\f[R],
\f[V]rtcSetGeometryIntersectFunction\f[R], and
\f[V]rtcSetGeometryOccludedFunction\f[R] functions on the implementation
of the callback functions.
.PP
Primitives of a user geometry are ignored during rendering when their
bounds are empty, thus bounds have lower>upper in at least one
dimension.
.PP
See tutorial [User Geometry] for an example of how to use the
user-defined geometries.
.SS EXIT STATUS
.PP
On failure \f[V]NULL\f[R] is returned and an error code is set that can
be queried using \f[V]rtcGetDeviceError\f[R].
.SS SEE ALSO
.PP
[rtcNewGeometry], [rtcSetGeometryUserPrimitiveCount],
[rtcSetGeometryUserData], [rtcSetGeometryBoundsFunction],
[rtcSetGeometryIntersectFunction], [rtcSetGeometryOccludedFunction]

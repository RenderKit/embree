.\" Automatically generated by Pandoc 2.5
.\"
.TH "rtcNewDevice" "3" "" "" "Embree Ray Tracing Kernels 3"
.hy
.SS NAME
.IP
.nf
\f[C]
rtcNewDevice \- creates a new device
\f[R]
.fi
.SS SYNOPSIS
.IP
.nf
\f[C]
#include <embree3/rtcore.h>

RTCDevice rtcNewDevice(const char* config);
\f[R]
.fi
.SS DESCRIPTION
.PP
This function creates a new device and returns a handle to this device.
The device object is reference counted with an initial reference count
of 1.
The handle can be released using the \f[C]rtcReleaseDevice\f[R] API
call.
.PP
The device object acts as a class factory for all other object types.
All objects created from the device (like scenes, geometries, etc.) hold
a reference to the device, thus the device will not be destroyed unless
these objects are destroyed first.
.PP
Objects are only compatible if they belong to the same device, e.g it is
not allowed to create a geometry in one device and attach it to a scene
created with a different device.
.PP
A configuration string (\f[C]config\f[R] argument) can be passed to the
device construction.
This configuration string can be \f[C]NULL\f[R] to use the default
configuration.
.PP
The following configuration is supported:
.IP \[bu] 2
\f[C]threads=[int]\f[R]: Specifies a number of build threads to use.
A value of 0 enables all detected hardware threads.
By default all hardware threads are used.
.IP \[bu] 2
\f[C]user_threads=[int]\f[R]: Sets the number of user threads that can
be used to join and participate in a scene commit using
\f[C]rtcJoinCommitScene\f[R].
The tasking system will only use threads\-user_threads many worker
threads, thus if the app wants to solely use its threads to commit
scenes, just set threads equal to user_threads.
This option only has effect with the Intel(R) Threading Building Blocks
(TBB) tasking system.
.IP \[bu] 2
\f[C]set_affinity=[0/1]\f[R]: When enabled, build threads are
affinitized to hardware threads.
This option is disabled by default on standard CPUs, and enabled by
default on Xeon Phi Processors.
.IP \[bu] 2
\f[C]start_threads=[0/1]\f[R]: When enabled, the build threads are
started upfront.
This can be useful for benchmarking to exclude thread creation time.
This option is disabled by default.
.IP \[bu] 2
\f[C]isa=[sse2,sse4.2,avx,avx2,avx512]\f[R]: Use specified ISA.
By default the ISA is selected automatically.
.IP \[bu] 2
\f[C]max_isa=[sse2,sse4.2,avx,avx2,avx512]\f[R]: Configures the
automated ISA selection to use maximally the specified ISA.
.IP \[bu] 2
\f[C]hugepages=[0/1]\f[R]: Enables or disables usage of huge pages.
Under Linux huge pages are used by default but under Windows and macOS
they are disabled by default.
.IP \[bu] 2
\f[C]enable_selockmemoryprivilege=[0/1]\f[R]: When set to 1, this
enables the \f[C]SeLockMemoryPrivilege\f[R] privilege with is required
to use huge pages on Windows.
This option has an effect only under Windows and is ignored on other
platforms.
See Section [Huge Page Support] for more details.
.IP \[bu] 2
\f[C]verbose=[0,1,2,3]\f[R]: Sets the verbosity of the output.
When set to 0, no output is printed by Embree, when set to a higher
level more output is printed.
By default Embree does not print anything on the console.
.IP \[bu] 2
\f[C]frequency_level=[simd128,simd256,simd512]\f[R]: Specifies the
frequency level the application want to run on, which can be either:
.RS 2
.IP "a)" 3
simd128 to run at highest frequency
.IP "b)" 3
simd256 to run at AVX2\-heavy frequency level
.IP "c)" 3
simd512 to run at heavy AVX512 frequency level.
When some frequency level is specified, Embree will avoid doing
optimizations that may reduce the frequency level below the level
specified.
E.g.
if your app does not use AVX instructions setting
\[lq]frequency_level=simd128\[rq] will cause some CPUs to run at highest
frequency, which may result in higher application performance if you do
much shading.
If you application heavily uses AVX code, you should best set the
frequency level to simd256.
Per default Embree tries to avoid reducing the frequency of the CPU by
setting the simd256 level only when the CPU has no significant down
clocking.
.RE
.PP
Different configuration options should be separated by commas, e.g.:
.IP
.nf
\f[C]
rtcNewDevice(\[dq]threads=1,isa=avx\[dq]);
\f[R]
.fi
.SS EXIT STATUS
.PP
On success returns a handle of the created device.
On failure returns \f[C]NULL\f[R] as device and sets a per\-thread error
code that can be queried using \f[C]rtcGetDeviceError(NULL)\f[R].
.SS SEE ALSO
.PP
[rtcRetainDevice], [rtcReleaseDevice]

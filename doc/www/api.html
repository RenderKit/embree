<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8' />
    <meta http-equiv="X-UA-Compatible" content="chrome=1" />
    <meta name="description" content="Embree: High Performance Ray Tracing Kernels" />
    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">
    <title>Embree</title>
    <link rel="SHORTCUT ICON" HREF="images/icon32.ico">
    <style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; }
code > span.dt { color: #902000; }
code > span.dv { color: #40a070; }
code > span.bn { color: #40a070; }
code > span.fl { color: #40a070; }
code > span.ch { color: #4070a0; }
code > span.st { color: #4070a0; }
code > span.co { color: #60a0b0; font-style: italic; }
code > span.ot { color: #007020; }
code > span.al { color: #ff0000; font-weight: bold; }
code > span.fu { color: #06287e; }
code > span.er { color: #ff0000; font-weight: bold; }
    </style>
  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
      <div class="inner">
        <a id="forkme_banner" href="https://github.com/embree">View on GitHub</a>
        <h1 id="project_title">Embree</h1>
        <h2 id="project_tagline">High Performance Ray Tracing Kernels</h2>
      </div>

      <div id="nav">
      <div id="nbar">
        <ul>
          <li><a href="index.html">Overview</a></li>
          <li><a href="downloads.html">Downloads</a></li>
          <li id="selected"><a href="api.html">API</a></li>
          <li><a href="tutorials.html">Tutorials</a></li>
          <li><a href="gallery.html">Gallery</a></li>
          <li><a href="renderer.html">Renderer</a></li>
        </ul>
      </div>
      </div>

    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <div id="main_content" class="inner">
<h1 id="embree-api">Embree API</h1>
<p>The Embree API is a low level ray tracing API that supports defining and committing of geometry and performing ray queries of different types. Static and dynamic scenes are supported, that may contain triangular geometry (including linear motions for motion blur), instanced geometry, and user defined geometry. Supported ray queries are, finding the closest scene intersection along a ray, and testing a ray segment for any intersection with the scene. Single rays, as well as packets of rays in a struct of array layout can be used for packet sizes of 1, 4, 8, and 16. Filter callback functions are supported, that get invoked for every intersection encountered during traversal.</p>
<p>The Embree API exists in a C++ and ISPC version. This document describes the C++ version of the API, the ISPC version is almost identical. The only differences are that the ISPC version needs some ISPC specific uniform type modifiers, and limits the ray packets to the native SIMD size the ISPC code is compiled for.</p>
<p>The user is supposed to include the <code>embree2/rtcore.h</code>, and the <code>embree2/rtcore_ray.h</code> file, but none of the other header files. If using the ISPC version of the API, the user should include <code>embree2/rtcore.isph</code> and <code>embree2/rtcore_ray.isph</code>.</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;embree2/rtcore.h&gt;</span>
<span class="ot">#include &lt;embree2/rtcore_ray.h&gt;</span></code></pre>
<p>All API calls carry the prefix <code>rtc</code> which stands for <strong>r</strong>ay <strong>t</strong>racing <strong>c</strong>ore. Before invoking any API call, the Embree ray tracing core has to get initialized through the <code>rtcInit</code> call. Before the application exits it should call <code>rtcExit</code>. Initializing Embree again after an <code>rtcExit</code> is allowed.</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">rtcInit(NULL);
...
rtcExit();</code></pre>
<p>The <code>rtcInit</code> call initializes the ray tracing core. An optional configuration string can be passed through this function to configure implementation specific parameters. If this string is <code>NULL</code>, a default configuration is used, that is optimal for most usages.</p>
<p>API calls that access geometries are only thread safe as long as different geometries are accessed. Accesses to one geometry have to get sequenced by the application. All other API calls are thread safe. The <code>rtcIntersect</code> and <code>rtcOccluded</code> calls are re-entrant, but only for other <code>rtcIntersect</code> and <code>rtcOccluded</code> calls. It is thus safe to trace new rays when intersecting a user defined object, but not supported to create new geometry inside the intersect function of a user defined geometry.</p>
<p>Each user thread has its own error flag in the API. If an error occurs when invoking some API function, this flag is set to an error code if it stores no previous error. The <code>rtcGetError</code> function reads and returns the currently stored error and clears the error flag again. For performance reasons the ray query functions do not set an error flag in release mode, but do so if Embree is compiled in debug mode.</p>
<p>Possible error codes returned by <code>rtcGetError</code> are:</p>
<table>
<caption>Return values of <code>rtcGetError</code>.</caption>
<colgroup>
<col width="33%" />
<col width="62%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">Error Code</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">RTC_NO_ERROR</td>
<td align="left">No error occurred.</td>
</tr>
<tr class="even">
<td align="left">RTC_UNKNOWN_ERROR</td>
<td align="left">An unknown error has occurred.</td>
</tr>
<tr class="odd">
<td align="left">RTC_INVALID_ARGUMENT</td>
<td align="left">An invalid argument was specified.</td>
</tr>
<tr class="even">
<td align="left">RTC_INVALID_OPERATION</td>
<td align="left">The operation is not allowed for the specified object.</td>
</tr>
<tr class="odd">
<td align="left">RTC_OUT_OF_MEMORY</td>
<td align="left">There is not enough memory left to complete the operation.</td>
</tr>
<tr class="even">
<td align="left">RTC_UNSUPPORTED_CPU</td>
<td align="left">The CPU is not supported as it does not support SSE2.</td>
</tr>
</tbody>
</table>
<p>Using the <code>rtcSetErrorFunction</code> call, it is also possible to set a callback function that is called whenever an error occurs. The callback function gets passed the error code, as well as some string that describes the error further. Passing <code>NULL</code> to <code>rtcSetErrorFunction</code> disables the set callback function again. The previously described error flags are also set if an error callback function is present.</p>
<h2 id="scene">Scene</h2>
<p>A scene is a container for a set of geometries of potentially different types. A scene is created using the <code>rtcNewScene</code> function call, and destroyed using the <code>rtcDeleteScene</code> function call. Two types of scenes are supported, dynamic and static scenes. Different flags specify the type of scene to create and the type of ray query operations that can later be performed on the scene. The following example creates a scene that supports dynamic updates and the single ray <code>rtcIntersect</code> and <code>rtcOccluded</code> calls.</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">RTCScene scene = rtcNewScene(RTC_SCENE_DYNAMIC, RTC_INTERSECT1);
...
rtcDeleteScene(scene);</code></pre>
<p>Using the following scene flags the user can select between creating a static and dynamic scene.</p>
<table>
<caption>Dynamic type flags for <code>rtcNewScene</code>.</caption>
<thead>
<tr class="header">
<th align="left">Scene Flag</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">RTC_SCENE_STATIC</td>
<td align="left">Scene is optimized for static geometry.</td>
</tr>
<tr class="even">
<td align="left">RTC_SCENE_DYNAMIC</td>
<td align="left">Scene is optimized for dynamic geometry.</td>
</tr>
</tbody>
</table>
<p>A dynamic scene is created by invoking <code>rtcNewScene</code> with the <code>RTC_SCENE_DYNAMIC</code> flag. Different geometries can now be created inside that scene. Geometries are enabled by default. Once the scene geometry is specified, an <code>rtcCommit</code> call will finish the scene description and trigger building of internal data structures. After the <code>rtcCommit</code> call it is safe to perform ray queries of the type specified at scene construction time. Geometries can get disabled (<code>rtcDisable</code> call), enabled again (<code>rtcEnable</code> call), and deleted (<code>rtcDeleteGeometry</code> call). Geometries can also get modified, including their vertex and index arrays. After the modification of some geometry, <code>rtcUpdate</code> or <code>rtcUpdateBuffer</code> has to get called for that geometry to specify which buffers got modified. Using multiple invocations of <code>rtcUpdateBuffer</code> the modified buffers can specified directly, while the <code>rtcUpdate</code> function simply tags each buffer of some geometry as modified. If geometries got enabled, disabled, deleted, or modified an <code>rtcCommit</code> call has to get invoked before performing any ray queries for the scene, otherwise the effect of the ray query is undefined.</p>
<p>A static scene is created by the <code>rtcNewScene</code> call with the <code>RTC_SCENE_STATIC</code> flag. Geometries can only be created and modified until the first <code>rtcCommit</code> call. After the <code>rtcCommit</code> call, each access to any geometry of that static scene is invalid, including enabling, disabling, modifying, and deletion of geometries. Consequently, geometries that got created inside a static scene can only get deleted by deleting the entire scene.</p>
<p>The following flags can be used to tune the used acceleration structure. These flags are only hints and may be ignored by the implementation.</p>
<table>
<caption>Acceleration structure flags for <code>rtcNewScene</code>.</caption>
<colgroup>
<col width="34%" />
<col width="62%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">Scene Flag</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">RTC_SCENE_COMPACT</td>
<td align="left">Creates a compact data structure and avoids algorithms that consume much memory.</td>
</tr>
<tr class="even">
<td align="left">RTC_SCENE_COHERENT</td>
<td align="left">Optimize for coherent rays (e.g. primary rays).</td>
</tr>
<tr class="odd">
<td align="left">RTC_SCENE_INCOHERENT</td>
<td align="left">Optimize for in-coherent rays (e.g. diffuse reflection rays).</td>
</tr>
<tr class="even">
<td align="left">RTC_SCENE_HIGH_QUALITY</td>
<td align="left">Build higher quality spatial data structures.</td>
</tr>
</tbody>
</table>
<p>The following flags can be used to tune the traversal algorithm that is used by Embree. These flags are only hints and may be ignored by the implementation.</p>
<table>
<caption>Traversal algorithm flags for <code>rtcNewScene</code>.</caption>
<colgroup>
<col width="26%" />
<col width="61%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">Scene Flag</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">RTC_SCENE_ROBUST</td>
<td align="left">Avoid optimizations that reduce arithmetic accuracy.</td>
</tr>
</tbody>
</table>
<p>The second argument of the <code>rtcNewScene</code> function are algorithm flags, that allow to specify which ray queries are required by the application. Calling for a scene a ray query API function that is different to the ones specified at scene creation time is not allowed. Further, the application should only pass ray query requirements that are really needed, to give Embree most freedom in choosing the best algorithm. E.g. in case Embree implements no packet traversers for some highly optimized data structure for single rays, then this data structure cannot be used if the user specifies any ray packet query.</p>
<table>
<caption>Enabled algorithm flags for <code>rtcNewScene</code>.</caption>
<colgroup>
<col width="25%" />
<col width="72%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">Algorithm Flag</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">RTC_INTERSECT1</td>
<td align="left">Enables the <code>rtcIntersect</code> and <code>rtcOccluded</code> functions (single ray interface) for this scene.</td>
</tr>
<tr class="even">
<td align="left">RTC_INTERSECT4</td>
<td align="left">Enables the <code>rtcIntersect4</code> and <code>rtcOccluded4</code> functions (4-wide packet interface) for this scene.</td>
</tr>
<tr class="odd">
<td align="left">RTC_INTERSECT8</td>
<td align="left">Enables the <code>rtcIntersect8</code> and <code>rtcOccluded8</code> functions (8-wide packet interface) for this scene.</td>
</tr>
<tr class="even">
<td align="left">RTC_INTERSECT16</td>
<td align="left">Enables the <code>rtcIntersect16</code> and <code>rtcOccluded16</code> functions (16-wide packet interface) for this scene.</td>
</tr>
</tbody>
</table>
<h2 id="geometries">Geometries</h2>
<p>Geometries are always contained in the scene they are created in. Each geometry is assigned an integer ID at creation time, which is unique for that scene. The current version of the API supports triangle meshes (<code>rtcNewTriangleMesh</code>), hair geometries (<code>rtcNewHairGeometry</code>), single level instances of other scenes (<code>rtcNewInstance</code>), and user defined geometries (<code>rtcNewUserGeometry</code>). The API is designed in a way that easily allows adding new geometry types in later releases.</p>
<p>For dynamic scenes, the assigned geometry IDs fulfill the following properties. As long as no geometry got deleted, all IDs are assigned sequentially, starting from 0. If geometries got deleted, the implementation will reuse IDs later on in an implementation dependent way. Consequently sequential assignment is no longer guaranteed, but a compact range of IDs. These rules allow the application to manage a dynamic array to efficiently map from geometry IDs to its own geometry representation.</p>
<p>For static scenes, geometry IDs are assigned sequentially starting at 0. This allows the application to use a fixed size array to map from geometry IDs to its own geometry representation.</p>
<h3 id="triangle-meshes">Triangle Meshes</h3>
<p>Triangle meshes are created using the <code>rtcNewTriangleMesh</code> function call, and potentially deleted using the <code>rtcDeleteGeometry</code> function call.</p>
<p>The number of triangles, the number of vertices, and optionally the number of time steps (1 for normal meshes, and 2 for linear motion blur) have to get specified at construction time of the mesh. The user can also specify additional flags that choose the strategy to handle that mesh in dynamic scenes. The following example demonstrates how to create a triangle mesh without motion blur:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">unsigned</span> geomID = rtcNewTriangleMesh(scene, geomFlags, numTriangles, numVertices);</code></pre>
<p>The following geometry flags can be specified at construction time of the triangle mesh:</p>
<table>
<caption>Flags for the creation of new geometries.</caption>
<colgroup>
<col width="34%" />
<col width="62%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">Geometry Flag</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">RTC_GEOMETRY_STATIC</td>
<td align="left">The mesh is considered static and should get modified rarely by the application. This flag has to get used in static scenes.</td>
</tr>
<tr class="even">
<td align="left">RTC_GEOMETRY_DEFORMABLE</td>
<td align="left">The mesh is considered to deform in a coherent way, e.g. a skinned character. The connectivity of the mesh has to stay constant, thus modifying the index array is not allowed. The implementation is free to choose a BVH refitting approach for handling meshes tagged with that flag.</td>
</tr>
<tr class="odd">
<td align="left">RTC_GEOMETRY_DYNAMIC</td>
<td align="left">The mesh is considered highly dynamic and changes frequently, possibly in an unstructured way. Embree will rebuild data structures from scratch for this type of mesh.</td>
</tr>
</tbody>
</table>
<p>The triangle indices can be set by mapping and writing to the index buffer (<code>RTC_INDEX_BUFFER</code>) and the triangle vertices can be set by mapping and writing into the vertex buffer (<code>RTC_VERTEX_BUFFER</code>). The index buffer contains an array of three 32 bit indices, while the vertex buffer contains an array of three float values aligned to 16 bytes. All buffers have to get unmapped before an <code>rtcCommit</code> call to the scene.</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> Vertex   { <span class="dt">float</span> x, y, z, a; };
<span class="kw">struct</span> Triangle { <span class="dt">int</span> v0, v1, v2; };

Vertex* vertices = (Vertex*) rtcMapBuffer(scene, geomID, RTC_VERTEX_BUFFER);
<span class="co">// fill vertices here</span>
rtcUnmapBuffer(scene, geomID, RTC_VERTEX_BUFFER);

Triangle* triangles = (Triangle*) rtcMapBuffer(scene, geomID, RTC_INDEX_BUFFER);
<span class="co">// fill triangle indices here</span>
rtcUnmapBuffer(scene, geomID, RTC_INDEX_BUFFER);</code></pre>
<p>Also see <a href="tutorials.html#tutorial00">tutorial00</a> for an example of how to create triangle meshes.</p>
<h3 id="subdivision-surfaces">Subdivision Surfaces</h3>
<p>Catmull Clark subdivision surfaces for meshes consisting of triangle and quad primitives (even mixed inside one mesh) are supported, including support for edge creases, vertex creases, holes, and non-manifold geometry.</p>
<p>A subdivision surface is created using the <code>rtcNewSubdivisionMesh</code> function call, and deleted again using the <code>rtcDeleteGeometry</code> function call.</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"> <span class="dt">unsigned</span> rtcNewSubdivisionMesh(RTCScene scene, 
                                RTCGeometryFlags flags,
                                size_t numFaces,
                                size_t numEdges,
                                size_t numVertices,
                                size_t numEdgeCreases,
                                size_t numVertexCreases,
                                size_t numCorners,
                                size_t numHoles,
                                size_t numTimeSteps);</code></pre>
<p>The number of faces (numFaces), edges/indices (numEdges), vertices (numVertices), edge creases (numEdgeCreases), vertex creases (numVertexCreases), holes (numHoles), and time steps (numTimeSteps) have to get specified at construction time.</p>
<p>The following buffers have to get setup by the application: the face buffer (RTC_FACE_BUFFER) contains the number edges/indices (3 or 4) of each of the numFaces faces, the index buffer (RTC_INDEX_BUFFER) contains multiple (3 or 4) 32bit vertex indices for each face and numEdges indices in total, the vertex buffer (RTC_VERTEX_BUFFER) stores numVertices vertices as single precision x,y,z floating point coordinates aligned to 16 bytes. The value of the 4th float used for alignment can be arbitrary.</p>
<p>Optionally, the application can setup the hole buffer (RTC_HOLE_BUFFER) with numHoles many 32 bit indices of faces that should be considered non-existing.</p>
<p>Optionally, the application can fill the level buffer (RTC_LEVEL_BUFFER) with a tessellation level for each of the numEdges edges. The subdivision level is a positive floating point value, that specifies how many quads along the edge should get generated during tessellation. The tessellation level is a lower bound, thus the implementation is free to choose a larger level. If no level buffer is specified a level of 1 is used.</p>
<p>Optionally, the application can fill the sparse edge crease buffers to make some edges appear sharper. The edge crease index buffer (RTC_EDGE_CREASE_INDEX_BUFFER) contains numEdgeCreases many pairs of 32 bit vertex indices that specify unoriented edges. The edge crease weight buffer (RTC_EDGE_CREASE_WEIGHT_BUFFER) stores for each of theses crease edges a positive floating point weight. The larger this weight, the sharper the edge. Specifying a weight of infinity is supported and marks an edge as infinitely sharp. Storing an edge multiple times with the same crease weight is allowed, but has lower performance. Storing the an edge multiple times with different crease weights results in undefined behavior. For a stored edge (i,j), the reverse direction edges (j,i) does not have to get stored, as both are considered the same edge.</p>
<p>Optionally, the application can fill the sparse vertex crease buffers to make some vertices appear sharper. The vertex crease index buffer (RTC_VERTEX_CREASE_INDEX_BUFFER), contains numVertexCreases many 32 bit vertex indices to specify a set of vertices. The vertex crease weight buffer (RTC_VERTEX_CREASE_WEIGHT_BUFFER) specifies for each of these vertices a positive floating point weight. The larger this weight, the sharper the vertex. Specifying a weight of infinity is supported and makes the vertex infinitely sharp. Storing a vertex multiple times with the same crease weight is allowed, but has lower performance. Storing a vertex multiple times with different crease weights results in undefined behavior.</p>
<p>Also see <a href="tutorials.html#tutorial08">tutorial08</a> for an example of how to create subdivision surfaces.</p>
<h3 id="hair-geometry">Hair Geometry</h3>
<p>Hair geometries are supported, which consist of multiple hairs represented as cubic Bézier curves with varying radius per control point. Individual hairs are considered to be subpixel sized which allows the implementation to approximate the intersection calculation. This in particular means that zooming onto one hair might show geometric artifacts.</p>
<p>Hair geometries are created using the <code>rtcNewHairGeometry</code> function call, and potentially deleted using the <code>rtcDeleteGeometry</code> function call.</p>
<p>The number of hair curves, the number of vertices, and optionally the number of time steps (1 for normal curves, and 2 for linear motion blur) have to get specified at construction time.</p>
<p>The curve indices can be set by mapping and writing to the index buffer (<code>RTC_INDEX_BUFFER</code>) and the control vertices can be set by mapping and writing into the vertex buffer (<code>RTC_VERTEX_BUFFER</code>). In case of linear motion blur, two vertex buffers (<code>RTC_VERTEX_BUFFER0</code> and <code>RTC_VERTEX_BUFFER1</code>) have to get filled, one for each time step.</p>
<p>The index buffer contains an array of 32 bit indices pointing to the ID of the first of four control vertices, while the vertex buffer stores all control pointing of a single precision position and radius stored in <code>x</code>, <code>y</code>, <code>z</code>, <code>r</code> order in memory. All buffers have to get unmapped before an <code>rtcCommit</code> call to the scene.</p>
<p>Like for triangle meshes, tee user can also specify a geometry mask and additional flags that choose the strategy to handle that mesh in dynamic scenes.</p>
<p>The following example demonstrates how to create some hair geometry:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">unsigned</span> geomID = rtcNewHairGeometry(scene, geomFlags, numCurves, numVertices);

<span class="kw">struct</span> Vertex { <span class="dt">float</span> x, y, z, r; };

Vertex* vertices = (Vertex*) rtcMapBuffer(scene, geomID, RTC_VERTEX_BUFFER);
<span class="co">// fill vertices here</span>
rtcUnmapBuffer(scene, geomID, RTC_VERTEX_BUFFER);

<span class="dt">int</span>* triangles = (<span class="dt">int</span>*) rtcMapBuffer(scene, geomID, RTC_INDEX_BUFFER);
<span class="co">// fill indices here</span>
rtcUnmapBuffer(scene, geomID, RTC_INDEX_BUFFER);</code></pre>
<p>Also see <a href="tutorials.html#tutorial07">tutorial07</a> for an example of how to create and use hair geometry.</p>
<h3 id="user-defined-geometry">User Defined Geometry</h3>
<p>User defined geometries make it possible to extend Embree with arbitrary types of geometry. This is achieved by introducing arrays of user geometries as a special geometry type. These objects do not contain a single user geometry, but a set of such geometries, each specified by an index. The user has to provide a user data pointer, bounding function as well as user defined intersect and occluded functions to create a set of user geometries. The user geometry to process is specified by passing its user data pointer and index to each invocation of the bounding, intersect, and occluded function. The bounding function is used to query the bounds of each user geometry. When performing ray queries, Embree will invoke the user intersect (and occluded) functions to test rays for intersection (and occlusion) with the specified user defined geometry.</p>
<p>As Embree supports different ray packet sizes, one potentially has to provide different versions of user intersect and occluded function pointers for these packet sizes. However, the ray packet size of the called user function always matches the packet size of the originally invoked ray query function. Consequently, an application only operating on single rays only has to provide single ray intersect and occluded function pointers.</p>
<p>User geometries are created using the <code>rtcNewUserGeometry</code> function call, and potentially deleted using the <code>rtcDeleteGeometry</code> function call. The following example illustrates creating an array with two user geometries:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> UserObject { ... };

<span class="dt">void</span> userBoundsFunction(UserObject* userGeom, size_t i, RTCBounds&amp; bounds) {
  bounds = &lt;bounds of userGeom[i]&gt;;
}

<span class="dt">void</span> userIntersectFunction(UserObject* userGeom, RTCRay&amp; ray, size_t i) {
  <span class="kw">if</span> (&lt;ray misses userGeom[i]&gt;)
    <span class="kw">return</span>;
  &lt;update ray hit information&gt;;
}

<span class="dt">void</span> userOccludedFunction(UserObject* userGeom, RTCRay&amp; ray, size_t i) {
  <span class="kw">if</span> (&lt;ray misses userGeom[i]&gt;)
    <span class="kw">return</span>;
  geomID = <span class="dv">0</span>;
}

...

UserObject* userGeom = <span class="kw">new</span> UserObject[<span class="dv">2</span>];
userGeom[<span class="dv">0</span>] = ...
userGeom[<span class="dv">1</span>] = ...
<span class="dt">unsigned</span> geomID = rtcNewUserGeometry(scene, <span class="dv">2</span>);
rtcSetUserData(scene, geomID, userGeom);
rtcSetBounds(scene, geomID, userBoundsFunction);
rtcSetIntersectFunction(scene, geomID, userIntersectFunction);
rtcSetOccludedFunction(scene, geomID, userOccludedFunction);</code></pre>
<p>The user intersect function (<code>userIntersectFunction</code>) and user occluded function (<code>userOccludedFunction</code>) get as input the pointer provided through the <code>rtcSetUserData</code> function call, a ray, and the index of the geometry to process. For ray packets, the user intersect and occluded functions also get a pointer to a valid mask as input. The user provided functions should not modify any ray that is disabled by that valid mask.</p>
<p>The user intersect function should return without modifying the ray structure if the user geometry is missed. If the geometry is hit, it has to update the hit information of the ray (<code>tfar</code>, <code>u</code>, <code>v</code>, <code>Ng</code>, <code>geomID</code>, <code>primID</code>).</p>
<p>Also the user occluded function should return without modifying the ray structure if the user geometry is missed. If the geometry is hit, it should set the <code>geomID</code> member of the ray to 0.</p>
<p>Is is supported to invoke the <code>rtcIntersect</code> and <code>rtcOccluded</code> function calls inside such user functions. It is not supported to invoke any other API call inside these user functions.</p>
<p>See <a href="tutorials.html#tutorial02">tutorial02</a> for an example of how to use the user defined geometries.</p>
<h3 id="instances">Instances</h3>
<p>Embree supports instancing of scenes inside another scene by some transformation. As the instanced scene is stored only a single time, even if instanced to multiple locations, this feature can be used to create extremely large scenes. Only single level instancing is supported by Embree natively, however, multi-level instancing can principally be implemented through user geometries.</p>
<p>Instances are created using the <code>rtcNewInstance</code> function call, and potentially deleted using the <code>rtcDeleteGeometry</code> function call. To instantiate a scene, one first has to generate the scene B to instantiate. Now one can add an instance of this scene inside a scene A the following way:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">unsigned</span> instID = rtcNewInstance(sceneA, sceneB);
rtcSetTransform(sceneA, instID, RTC_MATRIX_COLUMN_MAJOR, &amp;column_matrix_3x4);</code></pre>
<p>One has to call <code>rtcCommit</code> on scene B before one calls <code>rtcCommit</code> on scene A. When modifying scene B one has to call <code>rtcModified</code> for all instances of that scene. Providing a bounding box is not required and also not allowed. If a ray hits the instance, then the geomID and primID members of the ray are set to the geometry ID and primitive ID of the primitive hit in scene B, and the instID member of the ray is set to the instance ID returned from the <code>rtcNewInstance</code> function.</p>
<p>The <code>rtcSetTransform</code> call can be passed an affine transformation matrix with different data layouts:</p>
<table>
<caption>Matrix layouts for <code>rtcSetTransform</code>.</caption>
<colgroup>
<col width="48%" />
<col width="48%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">Layout</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">RTC_MATRIX_ROW_MAJOR</td>
<td align="left">The 3×4 float matrix is laid out in row major form.</td>
</tr>
<tr class="even">
<td align="left">RTC_MATRIX_COLUMN_MAJOR</td>
<td align="left">The 3×4 float matrix is laid out in column major form.</td>
</tr>
<tr class="odd">
<td align="left">RTC_MATRIX_COLUMN_MAJOR_ALIGNED16</td>
<td align="left">The 3×4 float matrix is laid out in column major form, with each column padded by an additional 4th component.</td>
</tr>
</tbody>
</table>
<p>Passing homogeneous 4×4 matrices is possible as long as the last row is (0, 0, 0, 1). If this homogeneous matrix is laid out in row major form, use the <code>RTC_MATRIX_ROW_MAJOR</code> layout. If this homogeneous matrix is laid out in column major form, use the <code>RTC_MATRIX_COLUMN_MAJOR_ALIGNED16</code> mode. In both cases, Embree will ignore the last row of the matrix.</p>
<p>The transformation passed to <code>rtcSetTransform</code> transforms from the local space of the instantiated scene to world space.</p>
<p>See <a href="tutorials.html#tutorial04">tutorial04</a> for an example of how to use instances.</p>
<h2 id="ray-queries">Ray Queries</h2>
<p>The API supports finding the closest hit of a ray segment with the scene (<code>rtcIntersect</code> functions), and determining if any hit between a ray segment and the scene exists (<code>rtcOccluded</code> functions).</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> rtcIntersect  (                   RTCScene scene, RTCRay&amp;   ray);
<span class="dt">void</span> rtcIntersect4 (<span class="dt">const</span> <span class="dt">void</span>* valid, RTCScene scene, RTCRay4&amp;  ray);
<span class="dt">void</span> rtcIntersect8 (<span class="dt">const</span> <span class="dt">void</span>* valid, RTCScene scene, RTCRay8&amp;  ray);
<span class="dt">void</span> rtcIntersect16(<span class="dt">const</span> <span class="dt">void</span>* valid, RTCScene scene, RTCRay16&amp; ray);
<span class="dt">void</span> rtcOccluded   (                   RTCScene scene, RTCRay&amp;   ray);
<span class="dt">void</span> rtcOccluded4  (<span class="dt">const</span> <span class="dt">void</span>* valid, RTCScene scene, RTCRay4&amp;  ray);
<span class="dt">void</span> rtcOccluded8  (<span class="dt">const</span> <span class="dt">void</span>* valid, RTCScene scene, RTCRay8&amp;  ray);
<span class="dt">void</span> rtcOccluded16 (<span class="dt">const</span> <span class="dt">void</span>* valid, RTCScene scene, RTCRay16&amp; ray);</code></pre>
<p>The ray layout to be passed to the ray tracing core is defined in the <code>embree2/rtcore_ray.h</code> header file. It is up to the user if he wants to use the ray structures defined in that file, or resemble the exact same binary data layout with their own vector classes. The ray layout might change with new Embree releases as new features get added, however, will stay constant as long as the major release number does not change. The ray contains the following data members:</p>
<table>
<caption>Data fields of a ray.</caption>
<thead>
<tr class="header">
<th align="left">Member</th>
<th align="left">In/Out</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">org</td>
<td align="left">in</td>
<td align="left">ray origin</td>
</tr>
<tr class="even">
<td align="left">dir</td>
<td align="left">in</td>
<td align="left">ray direction (can be unnormalized)</td>
</tr>
<tr class="odd">
<td align="left">tnear</td>
<td align="left">in</td>
<td align="left">start of ray segment</td>
</tr>
<tr class="even">
<td align="left">tfar</td>
<td align="left">in/out</td>
<td align="left">end of ray segment, set to hit distance after intersection</td>
</tr>
<tr class="odd">
<td align="left">time</td>
<td align="left">in</td>
<td align="left">time used for motion blur</td>
</tr>
<tr class="even">
<td align="left">mask</td>
<td align="left">in</td>
<td align="left">ray mask to mask out geometries</td>
</tr>
<tr class="odd">
<td align="left">Ng</td>
<td align="left">out</td>
<td align="left">unnormalized geometry normal</td>
</tr>
<tr class="even">
<td align="left">u</td>
<td align="left">out</td>
<td align="left">barycentric u-coordinate of hit</td>
</tr>
<tr class="odd">
<td align="left">v</td>
<td align="left">out</td>
<td align="left">barycentric v-coordinate of hit</td>
</tr>
<tr class="even">
<td align="left">geomID</td>
<td align="left">out</td>
<td align="left">geometry ID of hit geometry</td>
</tr>
<tr class="odd">
<td align="left">primID</td>
<td align="left">out</td>
<td align="left">primitive ID of hit primitive</td>
</tr>
<tr class="even">
<td align="left">instID</td>
<td align="left">out</td>
<td align="left">instance ID of hit instance</td>
</tr>
</tbody>
</table>
<p>This structure is in struct of array layout (SOA) for ray packets. Note that the <code>tfar</code> member functions as an input and output.</p>
<p>In the ray packet mode (with packet size of N), the user has to provide a pointer to N 32 bit integers that act as a ray activity mask. If one of these integers is set to <code>0x00000000</code> the corresponding ray is considered inactive and if the integer is set to <code>0xFFFFFFFF</code>, the ray is considered active. Rays that are inactive will not update any hit information. Data alignment requirements for ray query functions operating on single rays is 16 bytes for the ray.</p>
<p>Data alignment requirements for query functions operating on AOS packets of 4, 8, or 16 rays, is 16, 32, and 64 bytes respectively, for the valid mask and the ray. To operate on packets of 4 rays, the CPU has to support SSE, to operate on packets of 8 rays, the CPU has to support AVX-256, and to operate on packets of 16 rays, the CPU has to support the Xeon Phi™ instructions. Additionally, the required ISA has to be enabled in Embree at compile time to use the desired packet size.</p>
<p>Finding the closest hit distance is done through the <code>rtcIntersect</code> functions. These get the activity mask, the scene, and a ray as input. The user has to initialize the ray origin (<code>org</code>), ray direction (<code>dir</code>), and ray segment (<code>tnear</code>, <code>tfar</code>). The ray segment has to be in the range <span class="math">[0, ∞)</span>, thus ranges that start behind the ray origin are not valid, but ranges can reach to infinity. The geometry ID (<code>geomID</code> member) has to get initialized to <code>RTC_INVALID_GEOMETRY_ID</code> (-1). If the scene contains instances, also the instance ID (<code>instID</code>) has to get initialized to <code>RTC_INVALID_GEOMETRY_ID</code> (-1). If the scene contains linear motion blur, also the ray time (<code>time</code>) has to get initialized to a value in the range <span class="math">[0, 1]</span>. If ray masks are enabled at compile time, also the ray mask (<code>mask</code>) has to get initialized. After tracing the ray, the hit distance (<code>tfar</code>), geometry normal (<code>Ng</code>), local hit coordinates (<code>u</code>, <code>v</code>), geometry ID (<code>geomID</code>), and primitive ID (<code>primID</code>) are set. If the scene contains instances, also the instance ID (<code>instID</code>) is set, if an instance is hit. The geometry ID corresponds to the ID returned at creation time of the hit geometry, and the primitive ID corresponds to the <span class="math"><em>n</em></span>th primitive of that geometry, e.g. <span class="math"><em>n</em></span>th triangle. The instance ID corresponds to the ID returned at creation time of the instance.</p>
<p>The following code properly sets up a ray and traces it through the scene:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">RTCRay ray;
ray.org = ray_origin;
ray.dir = ray_direction;
ray.tnear = <span class="fl">0.f</span>;
ray.tfar = inf;
ray.geomID = RTC_INVALID_GEOMETRY_ID;
ray.primID = RTC_INVALID_GEOMETRY_ID;
ray.instID = RTC_INVALID_GEOMETRY_ID;
ray.mask = <span class="bn">0xFFFFFFFF</span>;
ray.time = <span class="fl">0.f</span>;
rtcIntersect(scene, ray);</code></pre>
<p>Testing if any geometry intersects with the ray segment is done through the <code>rtcOccluded</code> functions. Initialization has to be done as for <code>rtcIntersect</code>. If some geometry got found along the ray segment, the geometry ID (<code>geomID</code>) will get set to 0. Other hit information of the ray is undefined after calling <code>rtcOccluded</code>.</p>
<p>See <a href="tutorials.html#tutorial00">tutorial00</a> for an example of how to trace rays.</p>
<h2 id="buffer-sharing">Buffer Sharing</h2>
<p>Embree supports sharing of buffers with the application. Each buffer that can be mapped for a specific geometry can also be shared with the application, by pass a pointer, offset, and stride of the application side buffer using the <code>rtcSetBuffer</code> API function.</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> rtcSetBuffer(RTCScene scene, <span class="dt">unsigned</span> geomID, RTCBufferType type,
                  <span class="dt">void</span>* ptr, size_t offset, size_t stride);</code></pre>
<p>The <code>rtcSetBuffer</code> function has to get called before any call to <code>rtcMapBuffer</code> for that buffer, otherwise the buffer will get allocated internally and the call to <code>rtcSetBuffer</code> will fail. The buffer has to remain valid as long as the geometry exists, and the user is responsible to free the buffer when the geometry gets deleted. When a buffer is shared, it is safe to modify that buffer without mapping and unmapping it. However, for dynamic scenes one still has to call <code>rtcModified</code> for modified geometries and the buffer data has to stay constant from the <code>rtcCommit</code> call to after the last ray query invocation.</p>
<p>The <code>offset</code> parameter specifies a byte offset to the start of the first element and the <code>stride</code> parameter specifies a byte stride between the different elements of the shared buffer. This support for offset and stride allows the application quite some freedom in the data layout of these buffers, however, some restrictions apply. Index buffers always store 32 bit indices and vertex buffers always store single precision floating point data. The start address ptr+offset and stride always have to be aligned to 4 bytes on Xeon CPUs and 16 bytes on Xeon Phi™ accelerators, otherwise the <code>rtcSetBuffer</code> function will fail. For vertex buffers, the 4 bytes after the z-coordinate of the last vertex have to be readable memory, thus padding is required for some layouts.</p>
<p>The following is an example of how to create a mesh with shared index and vertex buffers:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">unsigned</span> geomID = rtcNewTriangleMesh(scene, geomFlags, numTriangles, numVertices);
rtcSetBuffer(scene, geomID, RTC_VERTEX_BUFFER, vertexPtr, <span class="dv">0</span>, <span class="dv">3</span>*<span class="kw">sizeof</span>(<span class="dt">float</span>));
rtcSetBuffer(scene, geomID, RTC_INDEX_BUFFER, indexPtr, <span class="dv">0</span>, <span class="dv">3</span>*<span class="kw">sizeof</span>(<span class="dt">int</span>));</code></pre>
<p>Sharing buffers can significantly reduce the memory required by the application, thus we recommend using this feature. When enabling the <code>RTC_COMPACT</code> scene flag, the spatial index structures of Embree might also share the vertex buffer, resulting in even higher memory savings.</p>
<p>The support for offset and stride is enabled by default, but can get disabled at compile time using the <code>RTCORE_BUFFER_STRIDE</code> parameter in CMake. Disabling this feature enables the default offset and stride which increases performance of spatial index structure build, thus can be useful for dynamic content.</p>
<h2 id="linear-motion-blur">Linear Motion Blur</h2>
<p>A triangle mesh or hair geometry with linear motion blur support is created by setting the number of time steps to 2 at geometry construction time. Specifying a number of time steps of 0 or larger than 2 is invalid. For a triangle mesh or hair geometry with linear motion blur, the user has to set the <code>RTC_VERTEX_BUFFER0</code> and <code>RTC_VERTEX_BUFFER1</code> vertex arrays, one for each time step.</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">unsigned</span> geomID = rtcNewTriangleMesh(scene, geomFlags, numTris, numVertices, <span class="dv">2</span>);
rtcSetBuffer(scene, geomID, RTC_VERTEX_BUFFER0, vertex0Ptr, <span class="dv">0</span>, <span class="kw">sizeof</span>(Vertex));
rtcSetBuffer(scene, geomID, RTC_VERTEX_BUFFER1, vertex1Ptr, <span class="dv">0</span>, <span class="kw">sizeof</span>(Vertex));
rtcSetBuffer(scene, geomID, RTC_INDEX_BUFFER, indexPtr, <span class="dv">0</span>, <span class="kw">sizeof</span>(Triangle));</code></pre>
<p>If a scene contains geometries with linear motion blur, the user has to set the <code>time</code> member of the ray to a value in the range <span class="math">[0, 1]</span>. The ray will intersect the scene with the vertices of the two time steps linearly interpolated to this specified time. Each ray can specify a different time, even inside a ray packet.</p>
<h2 id="geometry-mask">Geometry Mask</h2>
<p>A 32 bit geometry mask can be assigned to triangle meshes and hair geometries using the <code>rtcSetMask</code> call.</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">rtcSetMask(scene, geomID, mask);</code></pre>
<p>Only if the bitwise <code>and</code> operation of this mask with the mask stored inside the ray is not 0, primitives of this geometry are hit by a ray. This feature can be used to disable selected triangle mesh or hair geometries for specifically tagged rays, e.g. to disable shadow casting for some geometry. This API feature is disabled in Embree by default at compile time, and can be enabled in CMake through the <code>RTCORE_ENABLE_RAY_MASK</code> parameter.</p>
<h2 id="filter-functions">Filter Functions</h2>
<p>The API supports per geometry filter callback functions that are invoked for each intersection found during the <code>rtcIntersect</code> or <code>rtcOccluded</code> calls. The former ones are called intersection filter functions, the latter ones occlusion filter functions. The filter functions can be used to implement various useful features, such as accumulating opacity for transparent shadows, counting the number of surfaces along a ray, collecting all hits along a ray, etc. Filter functions can also be used to selectively reject hits to enable backface culling for some geometries. If the backfaces should be culled in general for all geometries then it is faster to enable <code>RTCORE_BACKFACE_CULLING</code> during compilation of Embree instead of using filter functions.</p>
<p>The filter functions provided by the user have to have the following signature:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> FilterFunc  (                   <span class="dt">void</span>* userPtr, RTCRay&amp;   ray);
<span class="dt">void</span> FilterFunc4 (<span class="dt">const</span> <span class="dt">void</span>* valid, <span class="dt">void</span>* userPtr, RTCRay4&amp;  ray);
<span class="dt">void</span> FilterFunc8 (<span class="dt">const</span> <span class="dt">void</span>* valid, <span class="dt">void</span>* userPtr, RTCRay8&amp;  ray);
<span class="dt">void</span> FilterFunc16(<span class="dt">const</span> <span class="dt">void</span>* valid, <span class="dt">void</span>* userPtr, RTCRay16&amp; ray);</code></pre>
<p>The <code>valid</code> pointer points to a valid mask of the same format as expected as input by the ray query functions. The <code>userPtr</code> is a user pointer optionally set per geometry through the <code>rtcSetUserData</code> function. The ray passed to the filter function is the ray structure initially provided to the ray query function by the user. For that reason, it is safe to extend the ray by additional data and access this data inside the filter function (e.g. to accumulate opacity). All hit information inside the ray is valid. If the hit geometry is instanced, the <code>instID</code> member of the ray is valid and the ray origin, direction, and geometry normal visible through the ray are in object space. The filter function can reject a hit by setting the <code>geomID</code> member of the ray to <code>RTC_INVALID_GEOMETRY_ID</code>, otherwise the hit is accepted. The filter function is not allowed to modify the ray input data (<code>org</code>, <code>dir</code>, <code>tnear</code>, <code>tfar</code>), but can modify the hit data of the ray (<code>u</code>, <code>v</code>, <code>Ng</code>, <code>geomID</code>, <code>primID</code>).</p>
<p>The intersection filter functions for different ray types are set for some geometry of a scene using the following API functions:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> rtcSetIntersectionFilterFunction  (RTCScene, <span class="dt">unsigned</span> geomID, RTCFilterFunc  );
<span class="dt">void</span> rtcSetIntersectionFilterFunction4 (RTCScene, <span class="dt">unsigned</span> geomID, RTCFilterFunc4 );
<span class="dt">void</span> rtcSetIntersectionFilterFunction8 (RTCScene, <span class="dt">unsigned</span> geomID, RTCFilterFunc8 );
<span class="dt">void</span> rtcSetIntersectionFilterFunction16(RTCScene, <span class="dt">unsigned</span> geomID, RTCFilterFunc16);</code></pre>
<p>These functions are invoked during execution of the <code>rtcIntersect</code> type queries of the matching ray type. The occlusion filter functions are set using the following API functions:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> rtcSetOcclusionFilterFunction  (RTCScene, <span class="dt">unsigned</span> geomID, RTCFilterFunc  );
<span class="dt">void</span> rtcSetOcclusionFilterFunction4 (RTCScene, <span class="dt">unsigned</span> geomID, RTCFilterFunc4 );
<span class="dt">void</span> rtcSetOcclusionFilterFunction8 (RTCScene, <span class="dt">unsigned</span> geomID, RTCFilterFunc8 );
<span class="dt">void</span> rtcSetOcclusionFilterFunction16(RTCScene, <span class="dt">unsigned</span> geomID, RTCFilterFunc16);</code></pre>
<p>See <a href="tutorials.html#tutorial05">tutorial05</a> for an example of how to use the filter functions.</p>
<h2 id="displacement-mapping-functions">Displacement Mapping Functions</h2>
<p>The API supports displacement mapping for subdivision meshes. A displacement function can be set for some subdivision mesh using the <code>rtcSetDisplacementFunction</code> API call.</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> rtcSetDisplacementFunction(RTCScene, <span class="dt">unsigned</span> geomID, RTCDisplacementFunc, RTCBounds* bounds);</code></pre>
<p>A displacement function of NULL will delete an already set displacement function. The bounds parameter is optional. If NULL is passed as bounds, then the displacement shader will get evaluated during the build process to properly bound displaced geometry. If a pointer to some bounds of the displacement are passed, then the implementation can choose to use these bounds to bound displaced geometry. When bounds are specified, then these bounds have to be conservative and should be tight for best performance.</p>
<p>The displacement function has to have the following type:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">typedef</span> <span class="dt">void</span> (*RTCDisplacementFunc)(<span class="dt">void</span>* ptr, <span class="dt">unsigned</span> geomID, <span class="dt">unsigned</span> primID,   
                                    <span class="dt">const</span> <span class="dt">float</span>* u,  <span class="dt">const</span> <span class="dt">float</span>* v,    
                                    <span class="dt">const</span> <span class="dt">float</span>* nx, <span class="dt">const</span> <span class="dt">float</span>* ny, <span class="dt">const</span> <span class="dt">float</span>* nz,   
                                    <span class="dt">float</span>* px, <span class="dt">float</span>* py, <span class="dt">float</span>* pz,         
                                    size_t N);</code></pre>
<p>The displacement function is called with the user data pointer of the geometry (ptr), the geometry ID (geomID) and primitive ID (primID) of a patch to displace. For this patch, a number N of points to displace are specified in a struct of array layout. For each point to displace the local patch UV coordinates (u and v arrays), the geometry normal (nx, ny, and nz arrays), as well as world space position (px, py, and pz arrays) are provided. The task of the displacement function is to use this information and move the world space position inside the allowed specified bounds around the point.</p>
<p>All passed arrays are guaranteed to be 64 bytes aligned, and properly padded to make wide vector processing inside the displacement function possible.</p>
<p>The displacement mapping functions might get called during the <code>rtcCommit</code> call, or lazily during one of the <code>rtcIntersect</code> or <code>rtcOccluded</code> calls.</p>
<h2 id="sharing-threads-with-embree">Sharing Threads with Embree</h2>
<p>Embree supports using the application threads when building internal data structures, by using the</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> rtcCommitThread(RTCScene, <span class="dt">unsigned</span> threadIndex, <span class="dt">unsigned</span> threadCount);</code></pre>
<p>API call to commit the scene. This function has to get called by all threads that want to cooperate in the scene commit. Each call is provided the scene to commit, the index of the calling thread in the range [0, <code>threadCount</code>-1], and the number of threads that will call into this commit operation for the scene. Multiple such scene commit operations can also be running at the same time, e.g. it is possible to commit many small scenes in parallel using one thread per commit operation. Subsequent commit operations for the same scene can use different number of threads or the Embree internal threads using the</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> rtcCommitThread()</code></pre>
<p>call.</p>
      </div>
    </div>

  </body>
</html>
